import { Injectable } from '@nestjs/common';
import { BadRequestException, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { User, Auth } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';
import * as bcrypt from 'bcrypt';
import { Totp } from 'time2fa';
import { CryptoService } from './crypto.service';
import { AUTH2FA_SECRET } from 'config';

export class Login42data {
  newuser: boolean;
  user: User;
  auth: Auth;
}

@Injectable()
export class AuthService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly jwtService: JwtService,
    private readonly cryptoService: CryptoService,
  ) {}

  // =========================================================================
  // SECTION 1: Login
  // =========================================================================

  async login42(profile: any): Promise<Login42data> {
    const username = profile.username;
    const email = profile.emails[0].value;

    const authData = await this.prisma.auth.findUnique({
      where: { email: email },
      include: { user: true },
    });

    if (authData) {
      const { user, ...auth } = authData;
      return { newuser: false, user: user, auth: auth };
    }

    /* new user */
    let newUsername: string = username;
    while (1) {
      try {
        const userData = await this.prisma.user.create({
          data: {
            username: newUsername,
            auth: {
              create: {
                email,
              },
            },
            profile: {
              create: { bio: '' },
            },
          },
          include: { auth: true },
        });

        const { auth, ...user } = userData;
        return { newuser: true, user: user, auth: auth };
      } catch (e) {
        if (e.code === 'P2002' || e.cause === 'Unique constraint failed.') {
          /* generate random username to avoid collision */
          newUsername = username + Math.floor(Math.random() * 1000);
        } else {
          throw e;
        }
      }
    }
  }

  accessToken(user: User) {
    return this.jwtService.sign({ sub: user.id });
  }

  async loginJwt(payload) {
    const userIdString = payload?.sub;
    if (userIdString == null) {
      throw new UnauthorizedException();
    }
    const userId = parseInt(userIdString, 10);
    if (isNaN(userId)) {
      throw new UnauthorizedException();
    }

    const user = await this.prisma.user.findUnique({ where: { id: userId } });
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }

  async validateStaff(username: string, password: string) {
    const user = await this.prisma.user.findUnique({
      where: { username: username },
      include: { auth: true },
    });
    if (user && bcrypt.compareSync(password, user.auth.password)) {
      return this.accessToken(user);
    }
    throw new UnauthorizedException();
  }

  // =========================================================================
  // SECTION 2: 2FA Login
  // =========================================================================

  /**
   * User already turned on 2fa login is attempting to login.
   *
   * @param user who is attempting to login with 2fa
   * @returns query of url to input 2fa code
   */
  async challenge2FA(user: User) {
    const data = await this.jwtService.signAsync(
      { id: user.id },
      { secret: AUTH2FA_SECRET, expiresIn: 3600 },
    );

    const token = await this.cryptoService.encrypt(data);
    return `token=${token}`;
  }

  /**
   * User input the 2fa code to login.
   *
   * @param token generated by challenge2FA function
   * @param code 2fa code input by user
   * @returns jwt token
   */
  async response2FA(token: string, code: string) {
    try {
      const data = await this.cryptoService.decrypt(token);

      const { id } = await this.jwtService.verifyAsync(data, {
        secret: AUTH2FA_SECRET,
      });
      const user = await this.prisma.user.findUnique({
        where: { id: id },
        include: { auth: true },
      });
      if (!user) {
        throw new UnauthorizedException('unknown client');
      }
      if (!user.auth.twoFactorAuthEnabled || !user.auth.twoFactorAuthSecret) {
        throw new UnauthorizedException('2FA not set for client');
      }

      if (!this.validate2FACode(user.auth, code)) {
        throw new BadRequestException('Invalid 2FA code');
      }

      return this.accessToken(user);
    } catch (error) {
      if (
        error instanceof UnauthorizedException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }
      throw new UnauthorizedException();
    }
  }

  private validate2FACode(auth: Auth, code: string) {
    return Totp.validate({
      passcode: code,
      secret: auth.twoFactorAuthSecret || '',
    });
  }

  // =========================================================================
  // SECTION 3: 2FA Setting
  // =========================================================================

  private async getAuth(user: User) {
    const auth = await this.prisma.auth.findUnique({
      where: { userId: user.id },
    });
    if (!auth) {
      throw new BadRequestException('Account not found');
    }
    return auth;
  }

  /**
   * User is attempting to enable 2fa.
   *
   * @param user who is attempting to enable 2fa
   * @returns totp url required to generate 2fa qr code
   */
  async generate2FASecret(user: User) {
    const auth = await this.getAuth(user);

    if (auth.staff) {
      throw new BadRequestException('Staff cannot enable 2FA login');
    }

    if (auth.twoFactorAuthEnabled) {
      throw new BadRequestException('2FA already enabled');
    }

    const { secret, url } = Totp.generateKey({
      issuer: 'Transcendence',
      user: user.username,
    });

    await this.prisma.auth.update({
      where: { userId: user.id },
      data: { twoFactorAuthSecret: secret },
    });
    return url;
  }

  /**
   * User input the 2fa code to enable 2fa.
   * This step is required to check if the user successfully setup 2fa.
   *
   * @param user who is attempting to enable 2fa
   * @param code 2fa code input by user
   */
  async enable2fa(user: User, code: string) {
    const auth = await this.getAuth(user);

    const valid = this.validate2FACode(auth, code);

    if (!valid) {
      throw new BadRequestException('Invalid 2FA code');
    }

    await this.prisma.auth.update({
      where: { userId: auth.userId },
      data: { twoFactorAuthEnabled: true },
    });

    return true;
  }

  /**
   * User attempts to disable 2fa.
   *
   * @param user who is attempting to enable 2fa
   * @param code 2fa code input by user
   */
  async disable2fa(user: User) {
    const auth = await this.getAuth(user);

    if (!auth.twoFactorAuthEnabled) {
      throw new BadRequestException('2FA already disabled');
    }

    await this.prisma.auth.update({
      where: { userId: auth.userId },
      data: { twoFactorAuthEnabled: false },
    });

    return true;
  }

  async is2faEnabled(user: User) {
    return await this.prisma.auth.findUnique({
      where: { userId: user.id },
      select: { staff: true, twoFactorAuthEnabled: true },
    });
  }

  // =========================================================================
  // SECTION 4: Other settings
  // =========================================================================

  async changeUsername(user: User, newUsername: string) {
    try {
      return await this.prisma.user.update({
        where: { id: user.id },
        data: { username: newUsername },
      });
    } catch (e) {
      if (e.code === 'P2002' || e.cause === 'Unique constraint failed.') {
        throw new BadRequestException('Username already taken');
      } else {
        throw e;
      }
    }
  }
}
